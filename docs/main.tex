\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage{csquotes}
\usepackage{caption}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tocbibind}
\usepackage{parskip}
\usepackage{titlesec}
\usepackage[style=ieee]{biblatex}

\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{2em}

\setcounter{tocdepth}{3}

\makeatletter
\renewcommand\tableofcontents{%
	\@starttoc{toc}%
}
\makeatother
\makeatletter
\renewcommand\listoffigures{%
        \@starttoc{lof}%
}
\makeatother

\addbibresource{bibliography.bib}

\captionsetup{font=small}

\title{Kedarium}
\author{Robin Patrik Sloup}

\begin{document}
\begin{titlepage}
	\begin{center}
		{\Large Gymnázium a Střední Odborná Škola\par}
		ul. Mládežníků 1115, Rokycany
	\end{center}
	\begin{center}
		\vspace{1cm}
		\includegraphics[height=3cm]{school-logo.png}\\
	\end{center}
	\vspace*{\fill}
	\begin{center}
		{\Huge \textbf{Kedarium,\\Grafický Engine}\par}
		\vspace{0.3cm}
		{\Large Maturitní Práce\par}
		\vspace{1.5cm}
	\end{center}
	\vspace*{\fill}
	\begin{center}
		\begin{minipage}[t]{0.45\textwidth}
			\centering
			\textbf{Autor Práce:}\\
			Robin Patrik Sloup
		\end{minipage}%
		\begin{minipage}[t]{0.45\textwidth}
			\centering
			\textbf{Vedoucí Práce:}\\
			Mgr. Jitka Fürbacherová
		\end{minipage}
	\end{center}
	\vspace{2cm}
	\begin{center}
		Rokycany 2024
	\end{center}
	\thispagestyle{empty}
\end{titlepage}
\setcounter{page}{2}
\section*{Prohlášení}
Prohlašuji, že jsem maturitní práci s názvem „Kedarium, Grafický Engine“ vypracoval samostatně pod vedením Mgr. Jitky Fürbacherové a uvedl v seznamu literatury všechny použité literární a odborné
zdroje. Dále prohlašuji, že citace použitých pramenů je úplná a že jsem v práci neporušil
autorská práva (ve smyslu zákona č. 121/2000 Sb. O právu autorském, o právech souvisejících
s právem autorským).

\vspace{24pt}
\noindent
V Rokycanech dne 11. 9. 2001
\pagebreak

\section*{Poděkování}

Mé poděkování patří Mgr. Jitce Fürbacherové za odborné vedení, ochotu a trpělivost, kterou mi v průběhu zpracování maturitní práce věnovala. Dále děkuji Jakubu Trnčákovi za pomoc při testování práce na systému MacOS.

\pagebreak

\section*{Obsah}
\tableofcontents
\pagebreak

\section*{Abstrakt}

\pagebreak

\section{Úvod}

Tato práce se zabývá problematikou tvorby grafického enginu — vývojové knihovny pro vývoj grafických aplikací, s využitím pouze základních, externích knihoven, díky kterému může programátor tvořit různé 3D scény a dodat jim svou vlastní funkcionalitu.

Pro tvorbu her či animací se často využívají komerční nástroje, které disponují širokou škálou možností a funkcí, pro tvorbu dechberoucích titulů a děl. Nevýhodou je, že zřídkakdy všechny tyto funkce vyžadujeme. Moderní herní enginy sice optimalizují výsledek, který jde do produkce, vždy ale bude obsahovat více kódu, než je třeba, a tak náš výsledný produkt nebude tak výkonný, jak by ve skutečnosti mohl být. Jedním z řešení je napsat si pro naší hru nebo projekt engine vlastní. Tímto způsobem můžeme optimalizovat každý aspekt, který musíme při tvorbě grafických programů zvážit a vytvořit tak dílo podle našich představ.

Pokud bychom pro každý grafický program, který tvoříme, psali ale engine vlastní, brzy bychom z časových důvodů moc takovýchto programů nevytvořili. Cílem této práce je vytvořit engine, který abstrahuje složitosti spojené s prací s grafickým rozhraním a zároveň nabízí výkonné řešení. Engine by měl být schopen abstrahovat základní koncepty, které jsou společné ve většině grafických projektech, na takovou úroveň, aby uživatel enginu věděl, co se v jeho programu děje a přitom se nemusel zabývat problematikou, která není pro jeho program specifická. Pod těmito koncepty si představme správu a tvorbu okna, získávání vstupu z klávesnice, pohyb v prostoru, operace s prostorem, načítání modelů ze souborů nebo např. simulace světla.

Engine by měl také být dostatečně modulární, díky čemuž nemusí být programátor závislý na celé jeho funkcionalitě, nýbrž na konkrétních, atomických částech. Pokud problém vývojáře vyžaduje jinou variantu, jak načítat modely těles, ale stále chce využít dostupné části enginu, nemá v cestě žádnou překážku pro realizaci vlastní části řešení. Je žádoucí, aby jednotlivé části práce šly využívat samostatně.

Konzistence je klíčem k úspěchu; engine by měl býti ve svém fungování a názvosloví celistvý. Programátor tak vždy bude chápat, co daná funkce vykonává, aniž by si musel dohledávat implementaci v samotném enginu. Moduly a funkce enginu musí býti konzistentně komentovány, pro jednoduchou a intuitivní práci s nimi. Díky tomuto faktoru pak mohou dílčí části tvořit fungující celek. Po seznámení s enginem by měl vývojář být schopný odvodit, co má daný modul či jeho část na starost i bez předchozích zkušeností a referencí.

Díky abstrakcím můžeme integrovat prvky enginu do vícero projektů bez znalosti implementace; nesmí se to však s abstrakcí přehánět. V momentě, kdy je logika příliš zobecněna, třetí osoba ztrácí pojem o tom, co se v jejím programu děje. Pak nemůžeme tvrdit, že engine usnadňuje práci — abstrakce se musí přizpůsobit vývojáři, nikoliv naopak. Engine se musí snažit o zjednodušení a srozumitelnost zároveň.

Engine si dává za cíl tyto jednotlivé podmínky splňovat a nabízet tak vývojářům možnost, jak učinit jejich práci při vývoji snazší, nerepetetivní a efektivní. Má býti střední cestou, mezi používáním komerčních řešení a tvořením všech dílů stavebnice od základu.

Následuje kapitola analýza, kde problematiku přiblížím více a rozvedu koncepty potřebné pro pochopení. Další kapitola se zabývá samotnou implementací a řešení problému, společně s ukázkami v kódu. Testování je věnována samotná, následné kapitola. Součástí práce je i uživatelský manuál pro spuštění a sestavení projektu vytvořeného tímto enginem.

\pagebreak

\section{Analýza}

Pro realizaci práce je nutné správně zvolit grafické rozhraní, programovací jazyk a chápat základní grafické koncepty. V této kapitole budou představeny různé nástroje pro řešení našeho problému a následně bude provedena diskuze na téma, jaké jsou klady a zápory daných řešení a samotné finální volby.

Na konci této kapitoly se zaměřím na popis matematických konceptů, jež budou pro vhodné řešení využity. Tyto koncepty se využívají primárně pro práci s prostorem. Nalézají ale i jiná využití — více o nich si povíme v kapitole implementace.

\subsection{Volba grafického rozhraní}

Grafické rozhraní můžeme považovat za střední bod mezi našimi instrukcemi v programu a samotnou grafickou kartou, která má na starost vykreslování grafiky v daném zařízení. Grafické karty mohou mít různé výrobce, samotný výrobce distribuuje různé modely, řady, verze, apod., a tedy odlišný způsob, jak danou instrukci musí karta vykonat. Ne každý grafický čip umožňuje vykonat danou instrukci, popřípadě ne na stejné úrovni.

Rozhraní pro programování aplikací, též API (Application Programing Interface), mají za úkol abstrahovat hardware či technologické rozdíly daného komponentu nebo systému a zobecnit tak práci s ním. Vývojář tedy nemusí přemýšlet nad implementací pro různé typy systémů, ale dostává standard, díky kterému může komunikovat se širokou škálou komponentů.

Grafické rozhraní představuje specifickou kategorii uživatelského rozhraní, jež nám umožňuje efektivně využívat možnosti grafických karet a zajišťuje jejich bezproblémovou komunikaci napříč různou hardwarovou výbavou. Potřebuji-li provést instrukci s grafickou kartou od společnosti NVIDIA, bez problému mohu funkcionalitu replikovat i na grafické kartě společnosti AMD. Nyní je důležité zvolit vhodné rozhraní pro náš projekt.

Několik nejběžněji používaných grafických rozhraní zahrnuje OpenGL \cite{opengl}, Vulkan \cite{vulkan}, DirectX \cite{directx}, WebGPU \cite{webgpu} a OpenGL ES \cite{opengles}. Začal jsem tím, že jsem eliminoval rozhraní, která nejsou určena pro řešení mého problému. Nebudu se zabývat jejich výhodami, či nevýhodami, neb pro tuto práci nejsou vhodné. Například, WebGPU je primárně určeno pro práci ve webových prohlížečích, kde umožňuje interakci s grafickou kartou pro výpočty a vykreslování v prohlížeči. Dále jsem eliminoval OpenGL ES. Toto API je cíleno pro embedded zařízení a mobilní systémy. Příkladem těchto zařízení mohou být konzole, mobilní telefony nebo chytrá vozidla. Více informací o tomto API lze nalézt na stránkách konsorcia Khronos Group \cite{khronos}. Jedná se o neziskové konsorcium, které vyvíjí standardy pro grafiku, virtuální a rozšířenou realitu nebo strojové učení. Některé standardy a specifikace, které vyvíjí toto konsorcium jsou: OpenGL, glTF, OpenCL a OpenXR.

Měl jsem tedy tři volby; OpenGL, DirectX a Vulkan. OpenGL široce rozšířený standard, který je téměř všude podporován. Poskytuje výkonné API s velkou komunitou a problémy, které s ním mohou vzniknout, jsou často již vyřešeny. Velkou výhodou je i multiplatformnost rozhraní. Ze stinné stránky si OpenGL prošlo mnoha změnami a můžeme tak nalézt spoustu zdrojů a materiálů, které jsou zastaralé. Navíc je API samo považováno za zastaralé s doporučením přechodu na Vulkan. Za nevýhodu lze považovat i to, že OpenGL nemá na starost jedna entita ale konsorcium; nemůže tedy existovat oficiální podpora.

Samotný Vulkan má stejně jako OpenGL na starost konsorcium Khronos Group. Umožňuje velmi detailní úpravy operací, které vedou k vykreslení grafiky na obrazovku. Pro vývojáře, kteří chtějí mít skvěle optimalizovaný engine, se kterým lze tvořit moderní hry nebo VR produkty, je toto API skvělá volba. Snaží se nezatěžovat procesor zařízení a směrovat práci grafické kartě. Také má velmi dobrou podporu pro multi-threading — schopnost souběžně vykonávat více operací naráz. Nevýhodou je, že se jedná o poměrně komplexní API. Začít s Vulkanem je složitější, než u většiny jiných API, kód aplikací je delší a tvorba prototypů a menších řešení, které nepotřebují využívat všech jeho funkcí, se tak značně zpomaluje.

Jako poslední představím DirectX. DirectX je kolekce proprietárních rozhraní vyvinutých společností Microsoft. Samotný grafický komponent DirectX se nazývá Direct3D. Toto API je primárně určeno pro hry. Snaží se o zpětnou kompatibilitu mezi verzemi a má rozsáhlou dokumentaci, spravovanou společností Microsoft. Má výbornou podporu pro systém Windows, protože je pro tento systém určen. Podpora dalších platforem ale není tak kvalitní. Někomu by také mohlo vadit, že vývoj API je přímo závislý na společnosti Microsoft a s vydáními se musí čekat právě na ni.

Můj cíl je vytvořit multiplatformní grafický engine, čemuž ne zcela vyhovuje API DirectX. Rozhodování je tedy mezi Vulkanem a OpenGL. Práci tvořím sám a tvorba řešení a implementace by s Vulkanem trvala značně déle. Dále také nevyžaduji pokročilé funkce, které Vulkan nabízí. Mou finální volbou se tedy stává OpenGL. Ačkoliv je považováno za zastaralé, nabízí i moderní verze, které se i dnes používají nejen v herním průmyslu. Má rozsáhlou komunitu a podporu, proto ho i přes zdánlivou zastaralost považuji za vhodné řešení.

\subsection{OpenGL}

OpenGL je standard, který nám dává možnost interagovat s daty, vykreslováním a zpracováním grafiky, bez ohledu na hardware zařízení. Slouží čistě pro práci s grafickou kartou a neřeší např. tvorbu okna, získání vstupu z klávesnice, načítání obrázků nebo načítání modelů. První verzi OpenGL vytvořila americká firma Silicon
Graphics Computer Systems v roce 1994. Nachází využití v mnoha průmyslech, ať už herním, věděckém nebo zdravotním. Funguje na bázi grafické pipeline — seřazený postup operací, který nám ze vstupních dat tvoří vizualizaci na obrazovce. Grafickou pipeline bychom mohli přirovnat k výrobní lince, kde každý její segment má pevně daný úkol, a na konci vzniká výsledný produkt.\cite{Shreiner_2013}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{opengl_pipeline.png}
    \caption[Grafická pipeline OpenGL]{Grafická pipeline OpenGL \cite{pipeline_img}}
    \label{fig:Grafická pipeline OpenGL}
\end{figure}
\pagebreak

Jak vidíme na Obrázku \ref{fig:Grafická pipeline OpenGL}, na začátku do pipeline zasíláme data o vrcholech. Tato data mohou obsahovat informaci o pozici vrcholu, jeho barvu, jeho normálový vektor, apod. Následně vektorový shader těmto datům dodá význam. Shader je malý program, který má za úkol přeměnit vstup na jiný výstup.\cite{lopgl_shaders} Díky vrcholovému shaderu víme, co jaká data reprezentují. Pipeline pokračuje geometrickým shaderem, který nemusíme implementovat. Uvnitř něj můžeme upravit zaslaná data o vrcholech, vrcholy odebrat nebo tvořit nové.\cite{lopgl_geometry_shader}

Dalším krokem je tvorba tvarů. V této fázi OpenGL přemění skupinu vrcholů na jednotlivé trojúhelníky. Trojúhelníky jsou vhodný útvar, neboť tři vrcholy jsou nejmenší nutný počet vrcholů pro definování roviny a dají se s nimi aproximovat všechny další tvary a tělesa. Nyní grafická pipeline provede proces rasterizace, který, jak vidíme na Obrázku \ref{fig:Grafická pipeline OpenGL}, přemění trojúhelníky na souřadnice na obrazovce. Pak přichází na řadu fragmentový shader. Ten může vrcholu přiřadit barvu, pixel z obrázku nebo na něj např. aplikovat světlo. Jako poslední krok spustí OpenGL několik testů. Může například zjistit, který objekt je vůči nám blíž a ten vykreslit, podobně, jako kdybychom skládali obrázky na papíru na sebe. Také se v tomto bodě zpracuje průhlednost ploch.

\subsection{Volba programovacího jazyka}

Velmi důležité je i správně zvolit programovací jazyk pro implementaci řešení. Musíme zvážit více faktorů jako dostupnost knihoven — souhrn již napsaného kódu pro daný účel (např. knihovna pro tvorbu a správu okna a jeho vstupů), výkon jazyka či jeho funkce. Pro řešení jsem chtěl použít jazyk, se kterým jsem se již setkal a mám s ním zkušenosti, aby mě neznalost daného jazyka nebrzdila či neomezovala při tvorbě programu. Rozhodoval jsem se mezi těmito jazyky: C, C++, Python a Java.

C \cite{kandr} je všestranný programovací jazyk, který v roce 1972 vytvořil Dennis Ritchie pro použití operačním systémem UNIX. Jedná se o nízkoúrovňový jazyk — programátor může ku příkladu přímo pracovat s pamětí počítače a tvořit vysoce optimalizované programy. Je to velmi rychlý a dodnes stále rozšířený jazyk. V tomto jazyce je napsaná spousta užitečných nástrojů, jako Git \cite{git}, Apache \cite{apache} nebo Linuxový \cite{linux} kernel. To, že je nízkoúrovňový, také ale znamená, že nepodporuje velké množství funkcí moderních programovacích jazyků a tvořit větší aplikace tímto jazykem by značně prodloužilo dobu vývoje a komplexitu kódu.

C++ \cite{cpp} bývá často považováno za nástupce C. Vytvořil ho Bjarne Stroustrup v roce 1979 a původně se jazyk jmenoval "C with classes". Dává si za cíl řešit problémy jazyka C, umožňuje psát kód různými paradigmaty — způsoby či schématy myšlení a snaží se také vytvořit nový pohled na psaní kódu. C++ je rychlý a flexibilní jazyk, který již v základu poskytuje velké množství funkcí. Tento jazyk umožňuje psaní nízkoúrovňového kódu a zároveň používání funkcí moderních jazyků. Nyní uvedu několik příkladů aplikací, které C++ využívají: Mozilla Firefox \cite{firefox}, Adobe Photoshop \cite{photoshop} či databáze MySQL \cite{mysql}. Nevýhodou C++ ale může být jeho složitost a rozsáhlost. Jazyk má spoustu standardů a často se stává, že projekty psané tímto jazykem používají svou vlastní část a implementaci jazyka. Člověku, který se s tímto jazykem nesetkal, bude trvat naučení se jazyka na pokročilou úroveň značně déle, než u jiných moderních a používaných jazyků.

Python \cite{python} se od C a C++ značně liší již v základu. Jedná se o jazyk interpretovaný, zatímco C a C++ jsou jazyky kompilované. To, že je Python interpretovaný, znamená, že se zdrojový kód převádí na strojový kód, kterému rozumí počítač, za chodu aplikace. U  kompilovaných jazyků se kód zpracuje naráz a vznikne nám spustitelná aplikace. Jedná se o velmi přizpůsobivý jazyk; nachází využití v grafice, zpracování dat, strojovém učení, v tvorbě desktopových aplikací a na spoustě dalších místech. Je dobře čitelný a dá se snadno naučit, proto je také často doporučován začínajícím programátorům. Také pro něj existuje velké množství knihoven, včetně knihoven pro práci s OpenGL. Jeho zásadní nevýhodou je ale výkon. Díky interpretaci kódu za chodu se stává poměrně pomalým. Oproti C (a to bez optimalizací) řeší Python většinu úkolů i 50x pomaleji. Pokud chceme psát optimalizovaný a výkonný kód, Python pravděpodobně není vhodná volba.

Jako poslední programovací jazyk jsem zvažoval jazyk Java \cite{java}. S tímto jazykem se mimo jiné setkávám i na škole, kde studuji. Jedná se o moderní, objektově orientovaný jazyk, který nabízí téměř bezkonkurenční podporu pro více platforem. Objektové programování \cite{oop} seskupuje atributy a chování do jednoho bloku, objektu, který vytváří šablona — třída. Tyto třídy můžou dále implementovat dědičnost. Řekněme, že mám třídu (šablonu) člověk. Ta může vytvořit objekt, který má parametry věk, jméno a bydliště. Také má svou funkcionalitu, může jíst, spát nebo studovat. Dědičná třídou by mohl být zaměstnanec, který má stejné atributy a chování jako třída člověk, mimo jiné má ale atribut plat a funkcionalitu pracování. Java je jazyk, který tento styl programování rozšířil a ovlivnil jím i další jazyky. Využívá technologii JVM (Java Virtual Machine)\cite{jvm}, díky které se její kód spouští na virtuálním hardware a není tak závislý na jeho fyzické implementaci. To umožňuje spouštět Java kód kdekoliv, kde JVM je. Díky spouštění skrze JVM ale nebývá tak rychlá jako standardní kompilované jazyky. Některým programátorům by také nemuselo vyhovovat, že se Java soustředí výhradně na objektově orientované paradigma. Při programování v Javě máme také poměrně omezené, jaké nízkoúrovňové funkcionality lze používat.

Nyní se pojďme zamyslet, jak pro práci zvolit vhodný jazyk. Úkolem práce je vytvořit grafický engine, který umí spravovat okno, získávat vstupy z počítače a pracovat s 3D prostorem. Grafický engine by měl být pokud možno co nejrychlejší, to znamená i volbu rychlého programovacího jazyka. Všechny zmíněné jazyky mají řadu knihoven pro interakci s API OpenGL a splňují tak základní požadavky enginu. Jako první jsem eliminoval programovací jazyk Python. Pro tvorbu enginu, který je rychlý a zároveň je schopný dostatečně abstrahovat OpenGL koncepty by použití Pythonu nebylo vhodné. Zbývalo mi tedy rozhodnout se mezi C, C++ a Javou. Jako další jsem odebral Javu, protože nemá tolik nízkoúrovňových funkcí jako C a C++. Zároveň mám v těchto jazycích i více zkušeností, než s jazykem Java. Dlouhou dobu jsem zvažoval, že pro realizaci práce zvolím jazyk C. Když jsem ale tvořil prototypy enginu, zjistil jsem, že vyvíjet tímto způsobem engine zabere poměrně velkou dobu, nebudu mít tolik možností abstrahování konceptů a změna logiky by znamenala přepsání většiny kódu.

Díky této zkušenosti jsem nakonec zvolil použití jazyka C++. Tento jazyk poskytuje možnost práce v objektově orientovaném stylu, což je vhodné pro abstrakci grafických konceptů do vlastních tříd, ale zároveň nabízí i práci s nízkoúrovňovými koncepty, jako např. operace s pamětí zařízení. Má také spoustu užitečných funkcí, které více přiblížím v kapitole, zabývající se implementací řešení.

\subsection{Grafické koncepty}

Pro implementaci je také nutné si atomizovat některé koncepty a shrnout si, k čemu slouží a jak je budeme moct využít. Vytvořil jsem si seznam těch, které je nutné dobře definovat, neboť na nich stojí základy celého programu. Jejich správná implementace je nutná pro fungování aplikace jako celku.

\subsubsection{Okno} \label{okno}

Okno je prvkem GUI (Graphical User Interface)\cite{gui}, grafického uživatelského rozhraní. Můžeme ho přirovnat k jakémusi inteligentnímu plátnu, které patří danému programu. Konkrétně v našem případě budeme na toto plátno vykreslovat grafiku. Samo okno může obsahovat další prvky uživatelského rozhraní, jako tlačítka, texty, zadávací pole a dalších mnoho elementů. Funkcionalita okna se liší na bázi jeho implementaci operačním systémem nebo jeho prostředím, můžeme však zobecnit funkce, které se mezi systémy téměř neliší. Okna lze minimalizovat (skrýt je), měnit jejich velikost, zavírat nebo s nimi vyplnit obrazovku. \cite{window}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{xp_window.png}
    \caption[Okno programu MS Word v operačním systému Windows XP]{Okno programu MS Word v operačním systému Windows XP \cite{xp_window}}
    \label{fig:Okno programu MS Word v operačním systému Windows XP}
\end{figure}

Na Obrázku \ref{fig:Okno programu MS Word v operačním systému Windows XP} můžeme vidět okno aplikace Microsoft Word \cite{word}, která běží na operačním systému Windows XP. Samotné okno má svůj titulek, který vidíme v horní modré liště. Na pravé straně se nacházejí tlačítka pro operace s oknem. Konkrétně Microsoft Word slouží pro tvorbu a úpravu dokumentů, má tedy i příslušné nástrojové lišty. Tvorba a správa okna je jedna z fundamentálních podmínek, pro vykreslování grafiky na obrazovku uživatele.

\subsubsection{Kamera}

Kameru si můžeme představit jako digitální oči programů pracujících s vykreslováním grafiky. Má svou pozici, směr pohledu a zorné pole — oblast, kterou můžeme pozorovat v daný moment. Může mít i další parametry, jako např. vzdálenost, do které kamera vidí. Nemusí pracovat jen s třírozměrným prostorem, můžeme mít kameru určenou pro plochu, která se často používá pro hry v pohledu z boku (např. Terraria \cite{terraria}) nebo pro vykreslování bokorysu (pohledu na objekt z boku) v technických programech. \cite{camera}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[width=14cm]{camera.png}
    \caption[Jednoduchý nákres fungování kamery]{Jednoduchý nákres fungování kamery \cite{camera_img}}
    \label{fig:Jednoduchý nákres fungování kamery}
\end{figure}

Jak vidíme na Obrázku \ref{fig:Jednoduchý nákres fungování kamery}, v závislosti na úhlu zorného pole, pozici a směru kamery můžeme ovlivnit, co se vykreslí uživateli na obrazovku. Kamery najdeme ve všech grafických hrách, technických programech či v modelovacích programech (např. v Blenderu \cite{blender}). Kvalitní implementace kamery a plynulých změn jejího stavu je podstatná pro kladnou uživatelskou zkušenost. Ku příkladu, kdyby se kamera při rotaci zasekávala nebo zkreslovala délky těles, nebude mít uživatel pocit, že se pohybuje realisticky působícím prostředím, ale spíše ne příliš kvalitní simulací prostoru. Kamera je jednoduchý koncept, který na první pohled nepůsobí jako elementární část programu. Musíme ale mít na paměti, že se jedná o koncept, se kterým uživatel interaguje většinu času — nekvalitní implementace uživateli neprodá kvalitní zážitek.

\subsubsection{Vertex Buffer Object}

Nyní zavedu grafický pojem, který je specifický pro naše vybrané grafické rozhraní, tedy OpenGL. VBO (Vertex Buffer Object) je buffer objekt, který se používá jako zdroj vrcholových dat. To je bez předchozího kontextu či znalostí téměř nic neříkající; pojďme si tedy tento pojem vysvětlit. Buffer objekt \cite{buffer_object} je kolekce dat, která má svůj specifický účel. Může například představovat informace o vrcholech (jednotlivých bodech těles) nebo informace o pixelech získaných z obrázku. \cite{vao_vbo_ebo}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{vbo.png}
    \caption{Příklad VBO s daty}
    \label{fig:Příklad VBO s daty}
\end{figure}

Konkrétně VBO má na starost seskupovat data o vrcholech. Na Obrázku \ref{fig:Příklad VBO s daty} můžeme vidět čtverec, který se skládá ze čtyř vrcholů. Vidíme, že každý vrchol má svou pozici a svou barvu. Pod čtvercem vidíme seznam hodnot, který se skládá z osmi trojic. Konkrétně zde náleží každému vrcholu právě 2 trojice — pro jeho pozici a barvu. Tento význam dává hodnotám vývojář, OpenGL u VBO nerozlišuje, která hodnota znamená jaký atribut.

\subsubsection{Element Buffer Object}

S VBO úzce souvisí Element Buffer Object, zkráceně EBO. Ten seskupuje data o tom, jaké trojúhelníky tvořit z dat o vrcholech. Již jsem zmínil, že OpenGL používá pro vykreslování ploch a těles trojúhelníky. Chci-li vykreslit čtverec, musím k sobě přiložit 2 shodné, pravoúhlé trojúhelníky. To by ale znamenalo, že potřebuji mít definovaných 6 vrcholů, 3 pro každý trojúhelník. Představme si, že chci vykreslit krychli. Každý vrchol je zároveň součástí tří stran. Znamená to, že pro vykreslení jednoduché krychle potřebuji definovat 24 vrcholů, přesto že ji lze vyjádřit vrcholy osmi. \cite{vao_vbo_ebo}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{ebo.png}
    \caption{Příklad EBO s daty}
    \label{fig:Příklad EBO s daty}
\end{figure}

Tuto problematiku řeší EBO, které nám udává, jak na bázi pořadí vrcholů ve VBO vykreslovat trojúhelníky. Použijeme stejný čtverec z příkladu k VBO a aplikujeme na něj tento princip. Čtverec popíšeme čtyřmi vrcholy a do EBO vložíme dvě trojice jenž popisují, jaké vrcholy trojúhelníky využívají. Na obrázku \ref{fig:Příklad EBO s daty} vidíme pořadí jednotlivých vrcholů a jak mohou data v EBO vypadat. Trojice $(0, 1, 2)$ vykreslí pravý dolní trojúhelník a trojice $(0, 2, 3)$ pak trojúhelník vlevo nahoře. Jedná se o malou ale efektivní optimalizaci, která v měřítku jednoho čtverce nepůsobí jako velká změna; většina detailních modelů má ale miliony trojúhelníků a tak optimalizace počtu potřebných vrcholů jedním z rozhodujících faktorů výkonu vykreslování našeho programu. Představme si EBO jako manuál ke skládání dat z VBO do jednoho celku pro naší grafickou kartu.

\subsubsection{Vertex Array Object}

Data v tento moment nemají pro OpenGL konkrétní význam; čte jen dlouhý seznam hodnot. Koncept, kterým můžeme OpenGL předat informace o datech vrcholů se nazývá VAO (Vertex Array Object). Podívejme se znovu na Obrázek \ref{fig:Příklad VBO s daty}, v sekci vysvětlující VBO. Můžeme data zobecnit a vytvořit si seznam informací o nich. Práce s VAO je v základu předání tohoto seznamu:

\begin{enumerate}
    \item Prvním komponentem je pozice.
    \item Pozice zabírá celkem 3 hodnoty.
    \item Pozice je reprezentována celými čísly.
    \item Mezi hodnotami není žádná mezera nebo jiná hodnota.
    \item Začátek další informace o pozici se opakuje po každých šesti hodnotách.
\end{enumerate}

Součástí popisu by pak mohlo být i to, kde může OpenGL najít barvy vrcholů, např. jako na Obrázku \ref{fig:Příklad VBO s daty}. Úkolem VAO je uchovávat hodnoty, společně s jejich formátem — popisem, jak jsou data rozsáhlá, kde je najít a o jaký druh hodnot se jedná. Nyní má OpenGL všechny informace, které potřebuje pro sestavení celku, dle našich potřeb. \cite{vao_vbo_ebo}

\subsubsection{Textura}

Textura je zpravidla dvourozměrný obrázek (v některých případech může mít dimenze jiné), který slouží pro přidání detailů objektu. Pokud by chtěl programátor vytvořit kamennou zeď, potřeboval by spoustu vrcholů, pro popsání jednotlivých výběžků, hrubosti povrchu či prasklin ve zdi. Texturu lze využít pro přidání detailů a dát tělesu více realistický vzhled. Také díky ní není potřeba přidávat více vrcholů a nedělat tak kompromisy na výkonu programu. Může se jednat o jakýkoliv obrázek, je ale poměrně důležité, aby byl čtvercový a jeho rozměry byly mocniny čísla 2, např. 16x16, 32x32, 128x128 nebo 1024x1024. Starší grafické karty mají problém s nečtvercovými formáty a také díky tomuto formátu může OpenGL aplikovat řadu optimalizací při práci s texturou. \cite{texture}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=10cm]{texture_example.png}
    \caption{Ukázka textury zdi}
    \label{fig:Ukázka textury zdi}
\end{figure}

Na Obrázku \ref{fig:Ukázka textury zdi} vidíme kvádr, který má texturu dlaždiček. Na první pohled tak působí, že se skutečně skládá z několika stovek kostiček, ve skutečnosti se jedná jen o obrázek, dodávající tento dojem. Při tvorbě scény musíme zvážit, jaký pocit má dávat uživateli. Jaký materiál by byl pro těleso vhodný? Jak detailní by samotná textura měla být? Při volbě textury je nutné zvolit takovou texturu, která nebude nevyčnívat a bude dostatečně realistická.

\subsubsection{Světlo}

Světlo je nejdůležitějším konceptem, který stojí za vizuální reprezentací čehokoliv, co může člověk vnímat. Ve skutečnosti nevidíme samotná tělesa, nýbrž paprsky světla, které se od těles odráží. Paprsky se mohou dále odrážet, být pohlceny nebo projít tělesem. Simulovat tento proces je ale výkonově vysoce náročné, a přestože s moderními grafickými čipy to možné je, pro naše účely práce nám bude stačit jednodušší řešení. Samotné světlo může mít několik druhů; ty nyní přiblížím. \cite{light}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=6cm]{light_img.jpeg}
    \caption[Různé druhy světel]{Různé druhy světel \cite{light_img}}
    \label{fig:Různé druhy světel}
\end{figure}

Prvním druhem světla je takzvané ambientní světlo — světlo prostředí. Kdybychom večer zhasnuli v místnosti světlo, stále matně uvidíme siluety objektů, potažmo jejich barvy. Důvodem je již zmíněné odrážení světla. Kolem nás je velké množství světelných zdrojů a tedy i nějaká úroveň světla. Na Obrázku \ref{fig:Různé druhy světel} vlevo nahoře vidíme, jak takový druh světla vypadá v praxi. Pokud chceme mít takovéto světlo v programu, musíme nalézt řešení, které není výkonnostně náročné a bude dostačující pro naše účely.

Dalším typem je světlo směrové, které na Obrázku \ref{fig:Různé druhy světel} vidíme vpravo nahoře. Je to světlo, jehož paprsky jsou rovnoběžné; směřují tedy vždy stejným směrem. V praxi se může jednat o slunečný svit, který v malém měřítku (např. oblast města Praha) působí, že svítí na všech místech stejným směrem. Ve velkém měřítku (např. ve sluneční soustavě) už hvězda působí jako jiný typ světla — jde o světlo bodové.

Bodové světlo vidíme na Obrázku \ref{fig:Různé druhy světel} vlevo dole. Je to jeden bod, který všemi směry vyzařuje stejnou sílu světla do prostoru. V praxi to může být žárovka, plamen svíce či hvězda ve vesmíru. Toto světlo se také společně s uplynutou délkou paprsků postupně vytrácí. Tomuto jevu říkáme atenuace světla \cite{attenuation}. Tento děj lze matematicky popsat:

\[f_a = \frac{1}{k_c + d \cdot k_l + d^2 \cdot k_q}\]

Kde $f_a$ popisuje násobek světla v daném bodě, $k_c$ je pak konstantní člen atenuace, $k_l$ lineární člen atenuace, $k_q$ kvadratický člen atenuace a samotné $d$ pak vzdálenost bodu od světelného zdroje. Úpravou těchto parametrů při implementaci můžeme dosáhnout různého chování úpadku světla.

Posledním typem světla jenž popíši je světlo kuželové. Ukázku tohoto světla můžeme vidět na Obrázku \ref{fig:Různé druhy světel}. Laicky by se dalo říci, že se jedná o kombinaci bodového a směrového světla. Jde  o světlo, které svítí z jednoho bodu v definovaném kuželu a stejně jako u bodového světla se jeho síla postupně vytrácí (efekt atenuace). \cite{spotlight}

\subsubsection{GUI}

GUI, jak již zaznělo Graphical User Interface, je druhem uživatelského rozhraní. Umožňuje nám interagovat s programem díky různým symbolům, tlačítkům či ikonám. Rovněž ale může zpětně díky GUI interagovat program s námi. \cite{gui2}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=9cm]{gui.png}
    \caption[Ukázka různých prvků GUI]{Ukázka různých prvků GUI \cite{gui_img}}
    \label{fig:Ukázka různých prvků GUI}
\end{figure}

Je důležité volit ikony a vzhledy prvků grafického rozhraní tak, abychom mohli snadno odvodit jejich význam a k čemu slouží. Na obrázku \ref{fig:Ukázka různých prvků GUI} vidíme příklad okna, které obsahuje různá tlačítka, tabulku, posuvníky či výběrová pole. Všechny tyto zmíněné prvky jsou určeny pro komunikaci uživatele s programem, nikoliv naopak.

Jak tedy může komunikovat program s uživatelem skrze GUI? Tuto interakci často vidíme ve hrách. Ukazatel počtu životů hráče, náhled mapy herního světa nebo například tachometr vozidla na obrazovce. Nyní popíši implementaci GUI na příkladu.

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=7cm]{minecraft.png}
    \caption[Snímek obrazovky ze hry Minecraft]{Snímek obrazovky ze hry Minecraft \cite{minecraft_img}}
    \label{Snímek obrazovky ze hry Minecraft}
\end{figure}

V dolní části Obrázku \ref{Snímek obrazovky ze hry Minecraft} vidíme lištu, společně s několika ikonami. Rudá srdce vlevo ukazují, kolik má hráč bodů života, malé ikonky kusů masa vpravo pak představují, jak moc je hráč nasycený. Ikony železného brnění nad životy popisují, jak kvalitní má hráč výzbroj. Mimo jiné v liště vidíme i některé předměty, která hráč vlastní. Malým detailem jsou i titulky vpravo, které vypisují zvukové události ve hře ze které směru samotný zvuk pochází.

 Takto může hra jednoduše sdělit uživateli informace o jeho stavu a okolí. Není tak potřeba vypisovat text uživateli o tom, zda se jeho postava musí najíst; tato informace je hráči zřejmá díky jednoduchým ikonám. Volba jednoduchý grafických prvků znamená i jejich jednoduché pochopení.

\subsection{Matematické koncepty}

Při tvorbě programu, který pracuje s prostorem, potřebujeme definovat samotný prostor a operace s ním popsat tak, aby jim program rozuměl. Touto problematikou se zabývá lineární algebra. Lineární algebra je odvětví matematiky, které rozvíjí algebru samotnou. Umožňuje nám práci s takzvanými vektory a vektorovým prostorem. lineárními transformacemi a soustavami lineárních rovnic. \cite{linear_algebra} Nyní popíši hlavní komponenty lineární algebry, které je pro správnou implementaci programu nutné pochopit.

\subsubsection{Vektor}

Vektor představuje veličinu, jenž má směr a velikost. Vektor si můžeme představit jako šipku o dané délce (velikosti) s konkrétním směrem. Jedná se o soubor seřazených hodnot. Vektory zapisujeme malými písmeny se šipkou nad písmenem ($\vec{a}$). Také je lze zapsat jako názvy bodů bez mezer s šipkou nad ($\vec{AB}$). \cite{vector}

Nyní budou popsány základní operace s vektory. Vektory můžeme např. sčítat, odečítat, získat jejich velikost, násobit číslem nebo získat tzv. skalární a vektorový součin, jenž popíšu na konci kapitoly. Sčítání vektorů je komutativní operace (nezáleží nám na jejich pořadí). Součtem vektorů vzniká vektor další, kde každá jeho složka je součtem složek vektorů sčítaných.

Vektory $\vec{a}$ a $\vec{b}$ jsou zapsány jako:
\begin{align}
    \vec{a} &= (4, -1, 2), \notag \\
    \vec{b} &= (-3, 8, -3).
\end{align}

Jejich součet $\vec{c} = \vec{a} + \vec{b}$ je pak:
\begin{align}
    \vec{c} &= (4 + (-3), (-1) + 8, 2 + (-3)) \notag \\
      &= (1, 7, -1).
\end{align}

\pagebreak

Stejným způsobem pak můžeme vektory odečítat; stačí záměna znaménka plus za znaménko minus. Odčítání vektorů je velmi užitečné, neboť máme-li body A a B s různými souřadnicemi, odečtem jejich souřadnic vyjádřených vektory získáváme tzv. vektor směrový. Směrový vektor popisuje směr mezi těmito body. V praxi tak můžeme popsat např. směr pohledu kamery — odečtem pozice kamery od bodu, na který cílí.

Považujme pozici kamery za bod $A$ a cílový bod za bod $B$, pak směrový vektor $\vec{AB}$ vypočteme takto:
\begin{align}
    \vec{AB} &= B - A
\end{align}

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=2.5cm]{vector_sub.png}
    \caption{Směrový vektor $\vec{AB}$}
    \label{fig:Směrový vektor AB}
\end{figure}

Na Obrázku \ref{fig:Směrový vektor AB} vidíme zakreslené naše body $A$ a $B$. Šipka mezi těmito body představuje směrový vektor $\vec{AB}$. Následně od sebe odečítáme jejich jednotlivé složky a získáváme hodnotu směrového vektoru. Další podstatnou operací při práci s vektory je získání jejich velikosti. Tento proces vychází z Pythagorovy věty \cite{pythagorean_theorem}. Mějme vektor $\vec{a}$:
\begin{align}
    \vec{a} &= (4, 3)
\end{align}

Pak je velikost tohoto vektoru rovna:
\begin{equation}
    |\vec{a}| = \sqrt{4^2 + 3^2} = \sqrt{25} = 5
\end{equation}

Obecně lze pak tvrdit, že velikost vektoru je rovna druhé odmocnině součtu druhých mocnin jeho složek. Vzorec pro získání velikosti n-dimenzionálního vektoru $\vec{v}$ vypadá následovně:
\begin{equation}
    |\vec{v}| = \sqrt{\sum_{i = 1}^{n} (\vec{v}_i)^2}
\end{equation}

V tomto vzorci představuje $n$ počet dimenzí (složek) vektoru, kde $n \in \mathbb{N}$. Chceme-li využít vektor pro reprezentaci směru v prostoru, jeho délka nás pravděpodobně nezajímá. Ideální by bylo mít vektor, který má délku rovnou právě 1. Když známe velikost vektoru, můžeme velikost upravit tak, aby měl velikost 1 a jeho směr zůstal zachován. Tomuto procesu říkáme normalizace vektoru, jehož výsledkem je vektor jednotkový (normalizovaný). Takovýto vektor značíme stříškou (vokání) nad jeho názvem. Stačí nám pouze vydělit jednotlivé složky vektoru jeho délkou:
\begin{equation}
    \hat{v} = \frac{\vec{v}}{|\vec{v}|} = \frac{\vec{v}}{\sqrt{\sum_{i = 1}^{n} (\vec{v}_i)^2}}
\end{equation}

Pro ukázku uvedu vektor $\vec{a}$ a získání jeho jednotkové verze ($\hat{a}$):
\begin{align}
    \vec{a} &= (5, 12, 0) \notag \\
    |\vec{a}| = \sqrt{5^2 + 12^2 + 0^2} &= \sqrt{25 + 144 + 0} = \sqrt{169} = 13 \notag \\
    \hat{a} = \frac{(5, 12, 0)}{13} &= (\frac{5}{13}, \frac{12}{13}, 0)
\end{align}

Další operace, která bude představena je tzv. skalární součin. Skalární součin dvou vektorů nám říká, jak podobné jsou směry, jímž vektory ukazují. Výsledkem této operace je jedna číselná hodnota Získáme ji součtem součinu první složky vektoru $\vec{a}$ a vektoru $\vec{b}$, následně součinu složek druhých, dokud nevyčerpáme všechny složky. V případě, že je skalární součin dvou nenulových vektorů roven číslu 0, pak jsou tyto vektory na sebe kolmé. Skalární součin zapisujeme jako standardní násobení (např. $\vec{a} \cdot \vec{b}$).

Takto vypadá výpočet skalárního součinu pro vektory $\vec{a}$ a $\vec{b}$:
\begin{align}
    \vec{a} &= (-4, -1, 2), \notag \\
    \vec{b} &= (-3, 8, 3) \notag \\
    \vec{a} \cdot \vec{b} &= (-4) \cdot (-3) + (-1) \cdot 8 + 2 \cdot 3 \notag \\
    \vec{a} \cdot \vec{b} &= 12 + (-8) + 6 = 10
\end{align}

Tento proces můžeme zobecnit tímto vzorcem:
\begin{equation}
    \vec{a} \cdot \vec{b} = \sum_{i=1}^{n}(\vec{a}_i \cdot \vec{b}_i)
\end{equation}

V tomto vzorci opět $n$ představuje počet dimenzí vektoru, přičemž platí $n \in \mathbb{N}$. Nyní detailněji představím operaci, která se nazývá vektorový součin. Vektorový součin je standardně definován pouze pro třídimenzionální vektory. Výsledkem vektorového součinu dvou vektorů $\vec{a}$ a $\vec{b}$ (zapíšeme $\vec{a} \times \vec{b}$) je vektor, jenž je kolmý na $\vec{a}$~i~$\vec{b}$.

\vspace{0.5cm}
\begin{figure}[h]
    \centering
    \includegraphics[height=3cm]{cross_product.png}
    \caption[Vektorový součin dvou vektorů]{Vektorový součin dvou vektorů \cite{gui_img}}
    \label{fig:Vektorový součin dvou vektorů}
\end{figure}

Pro $\vec{a}$ a $\vec{b}$ platí, že:
\begin{equation}
    \vec{a} \times \vec{b} = \begin{pmatrix}
        a_2 \cdot b_3 - a_3 \cdot b_2, \\
        a_3 \cdot b_1 - a_1 \cdot b_3, \\
        a_1 \cdot b_2 - a_2 \cdot b_1
    \end{pmatrix}
\end{equation}

Pro lepší představu o výpočtu demonstruji vektorový součin na příkladu:
\begin{align}
    \vec{a} &= (3, 4, -1), \notag \\
    \vec{b} &= (1, 7, -9)
\end{align}
\begin{equation}
    \vec{a} \times \vec{b} = \begin{pmatrix}
        4 \cdot (-9) - (-1) \cdot 7, \\
        (-1) \cdot 1 - 3 \cdot (-9), \\
        3 \cdot 7 - 4 \cdot 1
    \end{pmatrix} = \begin{pmatrix}
        -29 \\
        26, \\
        17 \cdot 7 - 4 \cdot 1
    \end{pmatrix}
\end{equation}

Nakonec uvedu, že vektory lze násobit (a tedy i dělit) jedním číslem. Toto číslo se nazývá skalár a bývá označováno řeckým písmenem lambda — $\lambda$. Tato operace pro třírozměrný vektor vypadá následovně:
\begin{equation}
    \lambda \cdot \vec{v} = (\lambda \cdot \vec{v}_1, \lambda \cdot \vec{v}_2, \lambda \cdot \vec{v}_3)
\end{equation}

Zde vidíme i příklad s konkrétními hodnotami:
\begin{equation}
    3 \cdot (4, 7, 3) = (3 \cdot 4, 3 \cdot 7, 3 \cdot 3) = (12, 21, 9)
\end{equation}

\subsubsection{Matice}

Matice je souborem hodnot, který můžeme rozdělit na sloupce a řádky. Jednotlivé hodnoty v ní nazýváme prvky množiny. U matic můžeme určit jejich rozměr (řád), který je udávaný jako počet řádků krát počet sloupců (např. $2 \times 3$). Tento řád můžeme u matice zapsat dolním indexem. \cite{matrix}

Zde je příklad matice $A$ s různými hodnotami, která má právě tři řádky a tři sloupce:
\begin{equation}
    A = \begin{bmatrix}
        1 & 2 & 3 \\
        4 & 5 & 9 \\
        7 & 8 & 10
    \end{bmatrix}_{3 \times 3}
\end{equation}

Tato konkrétní matice je zároveň příkladem speciálního druhu matic, neboť má stejný počet řádků a sloupců — jedná se o matici čtvercovou. Matice lze využívat více způsoby, pro práci je relevantní využití při transformacích (přeměnách) prostoru. Může se jednat o rotaci, posun či např. zkosení. Pro matice je stejně jako u vektorů definováno několik operací. Začnu popisem sčítání dvou matic.

Chci-li sčítat matice $A$ a $B$, pak musí býti jejich rozměry stejné. Pokud je tato podmínka splněna, mohu sčítat jednotlivé prvky tak, že do nové matice vložím součet prvků na dané pozici matic $A$ a $B$. Pro 2 matice o řádu $3 \times 3$:
\begin{equation}
    A + B = \begin{bmatrix}
        a_{11} + b_{11} & a_{12} + b_{12} & a_{13} + b_{13} \\
        a_{21} + b_{21} & a_{22} + b_{22} & a_{23} + b_{23} \\
        a_{31} + b_{31} & a_{32} + b_{32} & a_{33} + b_{33}
    \end{bmatrix}_{3 \times 3}
\end{equation}

Malé písmeno nám říká, že se jedná o prvek dané matice, dolní index pak prvním číslem udává řádek prvku a druhým číslem jeho sloupec. Např. $a_{23}$ je prvek matice $A$, jenž se nachází v druhém řádku a třetím sloupci. Nyní následuje ukázka, jak toto sčítání vypadá v praxi:
\begin{align}
    \begin{bmatrix}
        3 & 9 & -2 \\
        2 & -4 & -9 \\
        8 & 3 & 0
    \end{bmatrix} + \begin{bmatrix}
        9 & -1 & 5 \\
        -3 & 0 & -1 \\
        1 & 5 & 10
    \end{bmatrix} &= \begin{bmatrix}
        3 + 9 & 9 + (-1) & (-2) + 5 \\
        2 + (-3) & (-4) + 0 & (-9) + (-1) \\
        8 + 1 & 3 + 5 & 0 + 10
    \end{bmatrix} \notag \\
    &= \begin{bmatrix}
        12 & 8 & 3 \\
        -1 & -4 & -10 \\
        9 & 8 & 10
    \end{bmatrix}
\end{align}

Rozdíl dvou matic ($A - B$) je pak identický, stejně jako u vektorů nám postačí změna znaménka plus na minus. Součet a rozdíl nejsou jediné operace, které mají matice a vektory společné. Matice můžeme násobit skalárem (číslem) tak, že každý prvek budeme touto hodnotou násobit. V případě násobení matice $A$ řádu $3 \times 3$ skalárem $\lambda$, lze tuto operaci zobecnit takto:
\begin{equation}
    \lambda \cdot A = \begin{bmatrix}
        \lambda \cdot a_{11} & \lambda \cdot a_{12} & \lambda \cdot a_{13} \\
        \lambda \cdot a_{21} & \lambda \cdot a_{22} & \lambda \cdot a_{23} \\
        \lambda \cdot a_{31} & \lambda \cdot a_{32} & \lambda \cdot a_{33}
    \end{bmatrix}_{3x3}
\end{equation}

Kdybychom dosadili za $\lambda$ např. číslo $4$ a zvolili hodnoty pro matici, pak by dosazení vypadalo takto:
\begin{equation}
    4 \cdot \begin{bmatrix}
        3 & 9 & -2 \\
        2 & -4 & -9 \\
        8 & 3 & 0
    \end{bmatrix} = \begin{bmatrix}
        4 \cdot 3 & 4 \cdot 9 & 4 \cdot  (-2) \\
        4 \cdot 2 & 4 \cdot (-4) & 4 \cdot (-9) \\
        4 \cdot 8 & 4 \cdot 3 & 4 \cdot 0
    \end{bmatrix} = \begin{bmatrix}
        12 & 36 & -8 \\
        8 & -16 & -36 \\
        32 & 12 & 0
    \end{bmatrix}
\end{equation}

Všechny předešlé operace pro práci s maticemi byly vcelku intuitivní. Větší problém je násobení matice maticí. Aby bylo možné vynásobit matici $A$ maticí $B$, musí být splněna podmínka, že má matice $A$ stejný počet sloupců, jako má matice $B$ řádků. Následně se provádí skalární součin vektorů řádkových první matice s vektory sloupcovými matice druhé. Matematicky zapíšeme jako:
\begin{equation}
    (A \cdot B)_{ij} = \sum_{p=1}^{n}(a_{ip} \cdot {b_{pj}})
\end{equation}
\begin{figure}[h]
    \centering
    \includegraphics[height=4.2cm]{matrix_mp.png}
    \caption[Vizualizace násobení matic]{Vizualizace násobení matic \cite{matrix_mp_img}}
    \label{fig:Vizualizace násobení matic}
\end{figure}
\section{Implementace}

V této kapitole se zabývám implementací konceptů, které jsem vysvětlil v kapitole předešlé. Vypíši, jaké externí knihovny jsou využity pro jaké funkce, na jakém principu fungují jednotlivé části kódu a popíši, jak probíhal jejich vývoj. V sekci také budou ukázky kódu vysvětlovaných částí. V následující kapitole rozvedu, jak jsem fungování implementace testoval.

\subsection{Externí knihovny}

\subsection{Build systém}

\subsection{Okno}

\subsection{Správa vstupu}

\subsection{Barvy}

\subsection{Shadery}

\subsection{VAO, VBO a EBO}

\subsection{Práce s prostorem}

\subsection{Tělesa}

\subsection{Uživatelské rozhraní}

\subsection{Světlo}

\subsection{Čtení ze souborů}

\subsection{Třída Manager}

\subsection{Integrace pro debugging}

\section{Testování}

\section{Uživatelská příručka}

\subsection{Windows}

\subsection{MacOS}

\subsection{Linux}

\section{Závěr}

\pagebreak

\section{Seznam použité literatury}

\printbibliography[heading=none]

\section{Seznam obrázků a tabulek}

\listoffigures

\end{document}
